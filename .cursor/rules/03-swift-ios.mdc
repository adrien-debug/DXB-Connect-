---
description: Standards Swift/SwiftUI pour app iOS
globs: "**/*.swift"
alwaysApply: false
---

# Swift/SwiftUI - Standards iOS

## üì¶ Structure DXBCore Package

```
DXBCore/
‚îú‚îÄ‚îÄ Sources/DXBCore/
‚îÇ   ‚îú‚îÄ‚îÄ Models.swift          # Plan, ESIMOrder, Auth, Usage, Rewards, Offers, Crypto
‚îÇ   ‚îú‚îÄ‚îÄ Config.swift          # APIConfig + APIEndpoint (Railway uniquement)
‚îÇ   ‚îú‚îÄ‚îÄ APIClient.swift       # actor APIClient (request g√©n√©rique)
‚îÇ   ‚îú‚îÄ‚îÄ AuthService.swift     # actor AuthService (Keychain)
‚îÇ   ‚îú‚îÄ‚îÄ DXBAPIService.swift   # actor DXBAPIService (tous les endpoints)
‚îÇ   ‚îú‚îÄ‚îÄ TokenManager.swift    # actor TokenManager (refresh auto)
‚îÇ   ‚îú‚îÄ‚îÄ ApplePayService.swift # Apple Pay
‚îÇ   ‚îú‚îÄ‚îÄ StoreKitManager.swift # In-App Purchase
‚îÇ   ‚îî‚îÄ‚îÄ Logger.swift          # AppLogger actor + appLog()
‚îî‚îÄ‚îÄ Tests/DXBCoreTests/
    ‚îú‚îÄ‚îÄ APIClientTests.swift
    ‚îú‚îÄ‚îÄ AuthServiceTests.swift
    ‚îú‚îÄ‚îÄ ConfigTests.swift
    ‚îî‚îÄ‚îÄ TokenManagerTests.swift
```

## üèóÔ∏è Architecture App (Pattern r√©el)

```
DXBClientApp (@main)
‚îî‚îÄ‚îÄ RootView
    ‚îú‚îÄ‚îÄ splashView (isCheckingAuth)
    ‚îú‚îÄ‚îÄ AuthView (!isAuthenticated)
    ‚îî‚îÄ‚îÄ MainTabView (isAuthenticated)
        ‚îú‚îÄ‚îÄ DashboardView (Accueil)
        ‚îú‚îÄ‚îÄ MyESIMsView (Mes eSIM)
        ‚îú‚îÄ‚îÄ RewardsHubView (Rewards)
        ‚îî‚îÄ‚îÄ ProfileView (Profil)
```

### Gestion d'√©tat centralis√©e
```swift
// ‚úÖ Pattern R√âEL - @Observable + @Environment (iOS 17+)
@Observable
@MainActor
final class AppState {
    var isAuthenticated = false
    var currentUser: UserInfo?
    var isCheckingAuth = true
    var activeESIMs: [ESIMOrder] = []
    var subscription: SubscriptionResponse?
    var rewardsSummary: RewardsSummaryResponse?
    var partnerOffers: [PartnerOfferResponse] = []

    let authService: AuthService
    let apiClient: APIClient
    let apiService: DXBAPIService
    let tokenManager: TokenManager
}

// ‚úÖ Injection via @Environment
struct RootView: View {
    @State private var appState = AppState()

    var body: some View {
        Group { ... }
            .environment(appState)
    }
}

// ‚úÖ Consommation dans les vues
struct MyView: View {
    @Environment(AppState.self) private var appState
}
```

### ‚ùå Patterns OBSOL√àTES (ne PAS utiliser)
```swift
// ‚ùå NE PAS utiliser - ancien pattern
@StateObject private var viewModel = SomeViewModel()
@ObservedObject var vm: SomeVM
class SomeViewModel: ObservableObject { @Published var ... }

// ‚ùå NE PAS utiliser NavigationView
NavigationView { }

// ‚úÖ Utiliser NavigationStack
NavigationStack { }
```

## üîß Configuration API

```swift
// ‚úÖ Config.swift - URLs Railway (R√âELLES)
public enum APIConfig {
    public enum Environment {
        case development    // http://localhost:4000/api
        case staging        // https://web-production-14c51.up.railway.app/api
        case production     // https://web-production-14c51.up.railway.app/api ‚Üê NE JAMAIS CHANGER
    }

    public static var current: Environment = .production

    public static var baseURL: URL {
        switch current {
        case .development:
            return URL(string: "http://localhost:4000/api")!
        case .staging:
            return URL(string: "https://web-production-14c51.up.railway.app/api")!
        case .production:
            return URL(string: "https://web-production-14c51.up.railway.app/api")!
        }
    }
}

// ‚úÖ DXBClientApp.swift - Config actuelle
@main
struct DXBClientApp: App {
    init() {
        APIConfig.current = .production
    }
}
```

## üîê Authentification

### AuthService (actor + Keychain)
```swift
// ‚úÖ Pattern R√âEL
public actor AuthService: AuthServiceProtocol {
    func isAuthenticated() async -> Bool
    func getAccessToken() async throws -> String?
    func getRefreshToken() async throws -> String?
    func saveTokens(access: String, refresh: String?) async throws
    func clearTokens() async throws
}
```

### Sign In via DXBAPIService
```swift
// ‚úÖ Auth passe par DXBAPIService
let response: AuthResponse = try await apiService.signInWithApple(
    identityToken: token,
    authorizationCode: code,
    user: AppleUserInfo(email: email, name: name)
)

// ‚úÖ Apr√®s login, mettre √† jour AppState
appState.didSignIn(response: response)

// ‚úÖ Sign out
await appState.signOut()
```

## üì° API Client (actor)

```swift
// ‚úÖ Pattern R√âEL - APIClient est un actor
public actor APIClient {
    // Requ√™te avec string endpoint
    public func request<T: Decodable>(
        endpoint: String,
        method: String = "GET",
        body: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T

    // Requ√™te avec APIEndpoint enum
    public func request<T: Decodable>(
        endpoint: APIEndpoint,
        method: String = "GET",
        body: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T

    // Token management
    public func setAccessToken(_ token: String?)
    public func setTokenManager(_ manager: TokenManager)
}

// ‚úÖ DXBAPIService charge le token avant chaque requ√™te
if let token = try await authService.getAccessToken() {
    await apiClient.setAccessToken(token)
}
```

## üìù Logging

```swift
// ‚úÖ Pattern R√âEL - appLog() (fonction globale)
appLog("Fetching plans", level: .info, category: .data)
appLog("Auth failed: \(error.localizedDescription)", level: .error, category: .auth)

// ‚úÖ Via AppLogger.shared (actor)
await AppLogger.shared.logData("Fetched \(plans.count) plans")
await AppLogger.shared.logAuth("Login successful")
await AppLogger.shared.logAPIRequest(method: "GET", url: url, statusCode: 200, duration: 0.5)
await AppLogger.shared.logError(error, message: "Purchase failed", category: .api)

// ‚úÖ Niveaux: .debug, .info, .warning, .error, .critical
// ‚úÖ Cat√©gories: .api, .auth, .data, .ui, .network, .storage, .general

// ‚ùå Ne JAMAIS logger
appLog("Token: \(token)", category: .auth)  // ‚ùå Secret
appLog("Email: \(email)", category: .auth)  // ‚ùå PII
```

## üé® Design Tokens

### Couleurs
```swift
// ‚úÖ AppColors.* (source de v√©rit√© dans Theme.swift)
AppColors.accent          // #BAFF39 (lime)
AppColors.accentLight     // #D4FF85
AppColors.textPrimary     // Adaptatif light/dark
AppColors.textSecondary
AppColors.textTertiary
AppColors.textMuted
AppColors.background      // Adaptatif
AppColors.backgroundSecondary
AppColors.surface
AppColors.border
AppColors.success / .warning / .error / .info

// ‚úÖ AppTheme.* (alias de compatibilit√©)
AppTheme.accent           // ‚Üí AppColors.accent
AppTheme.textPrimary      // ‚Üí AppColors.textPrimary
```

### Spacing
```swift
// ‚úÖ AppSpacing.*
AppSpacing.xs   // 4pt
AppSpacing.sm   // 8pt
AppSpacing.md   // 12pt
AppSpacing.base // 16pt
AppSpacing.lg   // 20pt
AppSpacing.xl   // 24pt
AppSpacing.xxl  // 32pt
AppSpacing.xxxl // 48pt
```

### Border Radius
```swift
// ‚úÖ AppRadius.*
AppRadius.xs   // 6pt
AppRadius.sm   // 10pt
AppRadius.md   // 14pt
AppRadius.lg   // 18pt
AppRadius.xl   // 22pt
AppRadius.xxl  // 28pt
AppRadius.full // 9999pt
```

### Typography
```swift
// ‚úÖ AppFonts.*
AppFonts.heroAmount()    // 48pt bold rounded
AppFonts.detailAmount()  // 40pt bold rounded
AppFonts.sectionTitle()  // 22pt semibold
AppFonts.cardAmount()    // 18pt semibold
AppFonts.body()          // 15pt regular
AppFonts.caption()       // 13pt regular
AppFonts.small()         // 11pt regular
AppFonts.navTitle()      // 12pt bold
AppFonts.tabLabel()      // 14pt medium
AppFonts.button()        // 14pt bold
AppFonts.label()         // 10pt bold
```

### View Modifiers
```swift
// ‚úÖ Modifiers disponibles
.tokenCard()          // Card standard
.cleanCard()          // Alias tokenCard
.glassCard()          // Alias tokenCard
.techCard()           // Alias tokenCard
.shimmer()            // Effet shimmer loading
.slideIn(delay: 0.1)  // Animation d'entr√©e

// ‚úÖ Button Styles
.buttonStyle(GoldButtonStyle())       // Bouton primary (lime)
.buttonStyle(PrimaryButtonStyle())    // Alias GoldButtonStyle
.buttonStyle(SecondaryButtonStyle())  // Bouton secondary

// ‚úÖ Haptics
HapticFeedback.light()
HapticFeedback.medium()
HapticFeedback.success()
HapticFeedback.error()
```

### ‚ùå INTERDIT
```swift
// ‚ùå Jamais de couleurs hardcod√©es
Color(hex: "BAFF39")        // ‚ùå Utiliser AppColors.accent
.padding(16)                 // ‚ùå Utiliser AppSpacing.base
.cornerRadius(14)            // ‚ùå Utiliser AppRadius.md
.font(.system(size: 15))     // ‚ùå Utiliser AppFonts.body()
```

## üé® SwiftUI Views

### Structure type
```swift
// ‚úÖ Pattern standard
struct SomeView: View {
    @Environment(AppState.self) private var appState
    @State private var localState = false

    var body: some View {
        NavigationStack {
            Group {
                if appState.isDashboardLoading {
                    ProgressView()
                        .tint(AppColors.accent)
                } else {
                    content
                }
            }
        }
        .task {
            await appState.loadDashboard()
        }
    }
}
```

### Chargement parall√®le
```swift
// ‚úÖ async let pour charger en parall√®le
func loadDashboard() async {
    isDashboardLoading = true

    async let esims = loadESIMs()
    async let sub = loadSubscription()
    async let rewards = loadRewards()

    await esims
    await sub
    await rewards

    isDashboardLoading = false
}
```

### Composants r√©utilisables
```swift
// ‚úÖ EmptyStateView
EmptyStateView(
    icon: "simcard",
    title: "Aucune eSIM",
    subtitle: "Achetez votre premi√®re eSIM",
    actionTitle: "Explorer",
    action: { }
)

// ‚úÖ StatusBadge
StatusBadge(text: "Actif", color: AppColors.success)

// ‚úÖ LoadingOverlay
LoadingOverlay(message: "Chargement...")

// ‚úÖ CleanArcProgress
CleanArcProgress(progress: 0.65, lineWidth: 12, size: 160)
```

## üîÑ Mod√®les (Models.swift)

```swift
// ‚úÖ Mod√®les R√âELS
public struct Plan: Identifiable, Codable, Hashable {
    public let id: String           // packageCode
    public let name: String
    public let description: String
    public let dataGB: Int
    public let durationDays: Int
    public let priceUSD: Double
    public let speed: String        // "4G/LTE"
    public let location: String
    public let locationCode: String
}

public struct ESIMOrder: Identifiable, Codable, Hashable {
    public let id: String
    public let orderNo: String
    public let iccid: String
    public let lpaCode: String
    public let qrCodeUrl: String
    public let status: String       // smdpStatus
    public let packageName: String
    public let totalVolume: String
    public let expiredTime: String
    public let createdAt: Date
}

public struct AuthResponse: Codable {
    public let accessToken: String
    public let refreshToken: String?
    public let user: UserInfo
}

public struct UserInfo: Codable {
    public let id: String
    public let email: String?
    public let name: String?
}
```

## üß™ Tests

```swift
// ‚úÖ Tests dans DXBCoreTests/
import XCTest
@testable import DXBCore

final class APIClientTests: XCTestCase {
    func testFetchPlans() async throws {
        let client = APIClient()
        let plans: [Plan] = try await client.request(
            endpoint: "esim/packages",
            requiresAuth: true
        )
        XCTAssertFalse(plans.isEmpty)
    }
}
```

## üéØ Best Practices

1. **@Observable + @Environment** pour gestion d'√©tat (pas ObservableObject)
2. **actor** pour services (APIClient, AuthService, DXBAPIService, TokenManager)
3. **appLog()** pour logging (pas Logger.api.*)
4. **AppColors/AppSpacing/AppRadius/AppFonts** pour tokens (pas AppTheme.Spacing)
5. **NavigationStack** (pas NavigationView)
6. **async let** pour chargement parall√®le
7. **Railway UNIQUEMENT** comme backend (jamais de connexion directe Supabase/eSIM API)
8. **Keychain** pour tokens (via AuthService actor)
